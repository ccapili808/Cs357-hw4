-- Exercise 1
stutter :: [a] -> [a]
stutter [] = []
stutter (x:xs) = x : x : stutter xs

-- Exercise 2
compress :: Eq a => [a] -> [a]
compress [] = []
compress [x] = [x] 
compress (x:y:xs)
  | x == y   = compress (y:xs)
  | otherwise = x : compress(y:xs)

-- Exercise 3
findIndices :: Num b => (a -> Bool) -> [a] -> [b]
findIndices predicate list = findIndicesHelper predicate list 0
  where
    findIndicesHelper _ [] _ = []
    findIndicesHelper pred (x:xs) idx =
      if pred x
        then fromIntegral idx : findIndicesHelper pred xs (idx + 1)
        else findIndicesHelper pred xs (idx + 1)

intersect :: Eq a => [a] -> [a] -> [a]
intersect ls1 ls2 = [x | x <- ls1, x `elem` ls2]

-- Exercise 4
isPrefixOf :: Eq a => [a] -> [a] -> Bool
isPrefixOf [] _ = True
isPrefixOf _ [] = False
isPrefixOf (x:xs) (y:ys)
  | x == y = isPrefixOf xs ys
  | otherwise = False

-- Exercise 5
isSuffixOf :: Eq a => [a] -> [a] -> Bool
-- According to https://hoogle.haskell.org/?hoogle=drop, drop can help here. 
-- Remove the first n (length of suffix) items from the ls
-- Then compare the suffix and the list after we call drop 
isSuffixOf suffix ls = suffix == drop (length ls - length suffix) ls

-- Exercise 6
-- Using zip from https://hoogle.haskell.org/?hoogle=zip
-- Zip takes two lists and returns a list of corresponding pairs. 
-- Use sum and zip for dot product!
dot :: Num a => [a] -> [a] -> a
dot u v = sum [x * y | (x, y) <- zip u v]

-- Exercise 7
increasing :: Ord a => [a] -> Bool
increasing [] = True
increasing[x] = True
increasing (x:y:xs) = x <= y && increasing(y:xs)

-- Exercise 8
-- We need to eliminate every number where mod 10 is zero. 
-- Or conversely we need to keep every number where mod 10 is not zero. 
-- Filter is the most intuitive for me, we can filter out each instance where mod 10 = 0. 
-- However, when I tried to use filter, I ran into issues with tuples... So I needed to change my 
-- implementation in the following way: 
--     using zip, we can capture each item where mod 10 != 0. 
decimate :: [a] -> [a]
decimate ls = [x | (i, x) <- zip [1..] ls, i `mod` 10 /= 0]

-- Exercise 9
encipher :: Eq a => [a] -> [a] -> [a] -> [a]
encipher _ _ _ = undefined

-- Exercise 10
-- [1..10] -> [1,3,6,10,15,21,28,36,45,55]
-- [0+1, 1+2, 3+3, 6+4, ....] 
-- Using recursion we can add each item like it is done above. 
-- sum is an accumulator which starts at zero, and then adds the last calculation result to the 
-- current number in the list
prefixSum :: Num a => [a] -> [a]
prefixSum ls = prefixSum' ls 0
  where 
    prefixSum' []_ = []
    prefixSum' (x:ls) sum = (sum + x) : prefixSum' ls (sum + x) 

-- Exercise 11
select :: (t -> Bool) -> [t] -> [a] -> [a]
select _ _ _ = undefined

-- Exercise 12
-- The function numbers which takes a list of integers as its argument and returns the integer
-- which has those numbers as digits. For example,
-- Each number needs to be multiplied by: 
-- [1 2 3 4] -> 1234 
numbers :: [Integer] -> Integer
numbers _ = undefined 
